<!DOCTYPE html>
<script src="/resources/testharness.js" ></script>
<script src="/resources/testharnessreport.js"></script>
<script src="support/helper.sub.js"></script>

<meta http-equiv="Content-Security-Policy" content="trusted-types">
<body>
<script>
  // TODO: Split into smaller files?
  // Adopted from @koto's polyfill tests
  test(t => {
    const p = TrustedTypes.createPolicy('policy', {
      'createHTML': (s) => s,
    });
    let s = p.createHTML('foo');
    assert_equals(s + '', 'foo');
    assert_throws(new TypeError(), _ => {
      p.createScript('foo');
    });
    assert_throws(new TypeError(), _ => {
      p.createScriptURL('foo');
    });
    assert_throws(new TypeError(), _ => {
      p.createURL('foo');
    });
  }, 'TrustedTypesPolicy.createXXX methods can be used selectively.');

  // TODO: Does not throw
  const noopPolicy = {
          createHTML: (s) => s,
          createScriptURL: (s) => s,
          createURL: (s) => s,
          createScript: (s) => s,
  };

  test(t => {
    const p = TrustedTypes.createPolicy('frozen', noopPolicy);

    let html = p.createHTML('foo');

    assert_true(Object.isFrozen(html));
    assert_throws(new TypeError(), _ => {
      html.toString = () => 'fake';
    });
    assert_throws(new TypeError(), _ => {
      html.__proto__ = {toString: () => 'fake'};
    });
    assert_throws(new TypeError(), _ => {
      html.__proto__.toString = () => 'fake';
    });

    // Prevent sanitizer that passes javascript:... from masquerading.
    assert_throws(new TypeError(), _ => {
      Object.setPrototypeOf(html, TrustedTypes.TrustedURL.prototype);
    });

    // Proxy that traps get of toString.
    let proxyHtml = new Proxy(html, {
      get: (target, key, receiver) => {
        if (key === 'toString') {
          return () => 'fake';
        }
      },
    });

    assert_false(proxyHtml.toString() !== 'foo' && TrustedTypes.isHTML(proxyHtml));

    // Check that the attacks above don't succeed and throw.
    assert_true(TrustedTypes.isHTML(html));
    assert_false(TrustedTypes.isURL(html));
    assert_equals(String(html), 'foo');
  }, 'TrustedTypesPolicy.createXXX methods return frozen values.');

  // TODO: From enforcer tests.
  // What about the choice of elements and attributes?
  // To merge into HTMLElement-generic tests?
  test(t => {
    policy = TrustedTypes.createPolicy(Math.random(), noopPolicy, true);
    let el = document.createElement('div');
    assert_throws(new TypeError(), _ => {
      el.innerHTML = policy.createScript(INPUTS.SCRIPT);
    });
    assert_throws(new TypeError(), _ => {
      el.innerHTML = policy.createScriptURL(INPUTS.SCRIPTURL);
    });
    assert_throws(new TypeError(), _ => {
      el.innerHTML = policy.createURL(INPUTS.URL);
    });
    assert_equals(el.innerHTML, '');
  }, 'TrustedTypePolicy does not mix the types on innerHTML.');

  test(t => {
    policy = TrustedTypes.createPolicy(Math.random(), noopPolicy, true);
    let el = document.createElement('div');
    assert_throws(new TypeError(), _ => {
      el.insertAdjacentHTML('afterbegin', policy.createScript(INPUTS.SCRIPT));
    });
    assert_throws(new TypeError(), _ => {
      el.insertAdjacentHTML('afterbegin', policy.createScriptURL(INPUTS.SCRIPTURL));
    });
    assert_throws(new TypeError(), _ => {
      el.insertAdjacentHTML('afterbegin', policy.createURL(INPUTS.URL));
    });
    assert_equals(el.innerHTML, '');
  }, 'TrustedTypePolicy does not mix the types on Element.insertAdjacentHTML.');

  test(t => {
    policy = TrustedTypes.createPolicy(Math.random(), noopPolicy, true);
    let el = document.createElement('script');
    assert_throws(new TypeError(), _ => {
      el.src = policy.createHTML(INPUTS.HTML);
    });
    assert_throws(new TypeError(), _ => {
      el.src = policy.createScript(INPUTS.SCRIPT);
    });
    assert_throws(new TypeError(), _ => {
      el.src = policy.createURL(INPUTS.URL);
    });
    assert_equals(el.src, '');
  }, 'TrustedTypePolicy does not mix the types on HTMLScriptElement.src.');

  test(t => {
    policy = TrustedTypes.createPolicy(Math.random(), noopPolicy, true);
    let el = document.createElement('iframe');
    assert_throws(new TypeError(), _ => {
      el.src = policy.createHTML(INPUTS.HTML);
    });
    assert_throws(new TypeError(), _ => {
      el.src = policy.createScript(INPUTS.SCRIPT);
    });
    assert_throws(new TypeError(), _ => {
      el.src = policy.createScriptURL(INPUTS.SCRIPTURL);
    });
    assert_equals(el.src, '');
  }, 'TrustedTypePolicy does not mix the types on Element.prototype.setAttribute.');

  test(t => {
    policy = TrustedTypes.createPolicy(Math.random(), noopPolicy, true);
    let el = document.createElement('div');
    el.title = policy.createHTML(INPUTS.URL);
    assert_equals(el.title, INPUTS.URL);
    el.title = policy.createURL(INPUTS.HTML);
    assert_equals(el.title, '');
  }, 'TrustedTypePolicy does not mix the types on HTMLElement innocuous attribute.');

  // HTML tests
  function createHTMLTest(policyName, policy, expectedHTML, t) {
    let p = window.TrustedTypes.createPolicy(policyName, policy);
    assert_true(p.createHTML('whatever') instanceof TrustedHTML);
    // TODO: Add isHTML test here once TrustedXXX.isXXX() is implemented
    // assert_true(TrustedTypes.isHTML(html));
    assert_equals(p.createHTML('whatever') + "", expectedHTML);
  }

  test(t => {
    createHTMLTest('TestPolicyHTML1', { createHTML: s => s }, 'whatever', t);
  }, "html = identity function");

  test(t => {
    createHTMLTest('TestPolicyHTML2', { createHTML: s => null }, "null", t);
  }, "html = null");

  var HTMLstr = 'well, ';
  test(t => {
    createHTMLTest('TestPolicyHTML3', { createHTML: s => HTMLstr + s }, HTMLstr + 'whatever', t);
  }, "html = string + global string");

  var HTMLx = 'global';
  test(t => {
    createHTMLTest('TestPolicyHTML4', { createHTML: s => { HTMLx = s; return s; } }, 'whatever', t);
    assert_equals(HTMLx, 'whatever');
  }, "html = identity function, global string changed");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyHTML5', { createHTML: s => { throw new Error(); }});
    assert_throws(new Error(), _ => {
      p.createHTML('whatever');
    });
  }, "html = callback that throws");

  var obj = {
    "foo": "well,"
  }

  function getHTML(s) {
    return this.foo + " " + s;
  }

  test(t => {
    createHTMLTest('TestPolicyHTML6', { createHTML: getHTML.bind(obj) }, 'well, whatever', t);
  }, "html = this bound to an object");

  var foo = "well,";
  test(t => {
    createHTMLTest('TestPolicyHTML7', { createHTML: s => getHTML(s) }, 'well, whatever', t);
  }, "html = this without bind");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyHTML8', null);
    assert_throws(new TypeError(), _ => {
      p.createHTML('whatever');
    });
  }, "html - calling undefined callback throws");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyHTML9', { createHTML: createHTMLJS });
    assert_throws(new TypeError(), _ => {
      p.createScript(INPUTS.SCRIPT);
    });
    assert_throws(new TypeError(), _ => {
      p.createScriptURL(INPUTS.SCRIPTURL);
    });
    assert_throws(new TypeError(), _ => {
      p.createURL(INPUTS.URL);
    });
  }, "createHTML defined - calling undefined callbacks throws");

  // Script tests
  function createScriptTest(policyName, policy, expectedScript, t) {
    let p = window.TrustedTypes.createPolicy(policyName, policy);
    assert_true(p.createScript('whatever') instanceof TrustedScript);
    // TODO: Add isScript test here once TrustedXXX.isXXX() is implemented
    assert_equals(p.createScript('whatever') + "", expectedScript);
  }

  test(t => {
    createScriptTest('TestPolicyScript1', { createScript: s => s }, 'whatever', t);
  }, "script = identity function");

  test(t => {
    createScriptTest('TestPolicyScript2', { createScript: s => null }, "null", t);
  }, "script = null");

  var Scriptstr = 'well, ';
  test(t => {
    createScriptTest('TestPolicyScript3', { createScript: s => Scriptstr + s }, Scriptstr + 'whatever', t);
  }, "script = string + global string");

  var Scriptx = 'global';
  test(t => {
    createScriptTest('TestPolicyScript4', { createScript: s => { Scriptx = s; return s; } }, 'whatever', t);
    assert_equals(Scriptx, 'whatever');
  }, "script = identity function, global string changed");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyScript5', {
      createScript: s => { throw new Error(); }
    });
    assert_throws(new Error(), _ => {
      p.createScript('whatever');
    });
  }, "script = callback that throws");

  var obj = {
    "foo": "well,"
  }

  function getScript(s) {
    return this.foo + " " + s;
  }

  test(t => {
    createScriptTest('TestPolicyScript6', { createScript: getScript.bind(obj) }, 'well, whatever', t);
  }, "script = this bound to an object");

  var foo = "well,";
  test(t => {
    createScriptTest('TestPolicyScript7', { createScript: s => getScript(s) }, 'well, whatever', t);
  }, "script = this without bind");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyScript8', null);
    assert_throws(new TypeError(), _ => {
      p.createScript('whatever');
    });
  }, "script - calling undefined callback throws");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyScript9', { createScript: createScriptJS });
    assert_throws(new TypeError(), _ => {
      p.createHTML(INPUTS.HTML);
    });
    assert_throws(new TypeError(), _ => {
      p.createScriptURL(INPUTS.SCRIPTURL);
    });
    assert_throws(new TypeError(), _ => {
      p.createURL(INPUTS.URL);
    });
  }, "createScript defined - calling undefined callbacks throws");


  // ScriptURL tests
  function createScriptURLTest(policyName, policy, expectedScriptURL, t) {
    let p = window.TrustedTypes.createPolicy(policyName, policy);
    assert_true(p.createScriptURL(INPUTS.SCRIPTURL) instanceof TrustedScriptURL);
    // TODO: Add isScriptURL test here once TrustedXXX.isXXX() is implemented
    assert_equals(p.createScriptURL(INPUTS.SCRIPTURL) + "", expectedScriptURL);
  }

  test(t => {
    createScriptURLTest('TestPolicyScriptURL1', { createScriptURL: s => s }, INPUTS.SCRIPTURL, t);
  }, "script_url = identity function");

  test(t => {
    createScriptURLTest('TestPolicyScriptURL2', { createScriptURL: s => null }, "", t);
  }, "script_url = null");

  var scriptURLstr = '#duck';
  test(t => {
    createScriptURLTest('TestPolicyScriptURL3', { createScriptURL: s => s + scriptURLstr }, INPUTS.SCRIPTURL + scriptURLstr, t);
  }, "script_url = string + global string");

  var scriptURLx = 'global';
  test(t => {
    createScriptURLTest('TestPolicyScriptURL4', { createScriptURL: s => { ScriptURLx = s; return s; } }, INPUTS.SCRIPTURL, t);
    assert_equals(ScriptURLx, INPUTS.SCRIPTURL);
  }, "script_url = identity function, global string changed");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyScriptURL5', {
      createScriptURL: s => { throw new Error(); }
    });
    assert_throws(new Error(), _ => {
      p.createScriptURL(INPUTS.SCRIPTURL);
    });
  }, "script_url = callback that throws");

  function getScriptURL(s) {
    return s + this.baz;
  }

  var obj = {
    "baz": "#duck"
  }

  test(t => {
    createScriptURLTest('TestPolicyScriptURL6', { createScriptURL: getScriptURL.bind(obj) }, INPUTS.SCRIPTURL + "#duck", t);
  }, "script_url = this bound to an object");

  var baz = "#duck";
  test(t => {
    createScriptURLTest('TestPolicyScriptURL7', { createScriptURL: s => getScriptURL(s) }, INPUTS.SCRIPTURL + baz, t);
  }, "script_url = this without bind");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyScriptURL8', null);
    assert_throws(new TypeError(), _ => {
      p.createScriptURL(INPUTS.SCRIPTURL);
    });
  }, "script_url - calling undefined callback throws");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyScriptURL9', { createScriptURL: createScriptURLJS });
    assert_throws(new TypeError(), _ => {
      p.createHTML(INPUTS.HTML);
    });
    assert_throws(new TypeError(), _ => {
      p.createScript(INPUTS.SCRIPT);
    });
    assert_throws(new TypeError(), _ => {
      p.createURL(INPUTS.URL);
    });
  }, "createScriptURL defined - calling undefined callbacks throws");


  // URL tests
  function createURLTest(policyName, policy, expectedURL, t) {
    let p = window.TrustedTypes.createPolicy(policyName, policy);
    assert_true(p.createURL(INPUTS.URL) instanceof TrustedURL);
    // TODO: Add isURL test here once TrustedXXX.isXXX() is implemented
    assert_equals(p.createURL(INPUTS.URL) + "", expectedURL);
  }

  test(t => {
    createURLTest('TestPolicyURL1', { createURL: s => s }, INPUTS.URL, t);
  }, "url = identity function");

  test(t => {
    createURLTest('TestPolicyURL2', { createURL: s => null }, "", t);
  }, "url = null");

  var URLstr = '#x';
  test(t => {
    createURLTest('TestPolicyURL3', { createURL: s => s + URLstr }, INPUTS.URL + URLstr, t);
  }, "url = string + global string");

  var URLx = 'global';
  test(t => {
    createURLTest('TestPolicyURL4', { createURL: s => { URLx = s; return s; } }, INPUTS.URL, t);
    assert_equals(URLx, INPUTS.URL);
  }, "url = identity function, global string changed");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyURL5', {
      createURL: s => { throw new Error(); }
    });
    assert_throws(new Error(), _ => {
      p.createURL(INPUTS.URL);
    });
  }, "url = callback that throws");

  function getURL(s) {
    return s + this.bar;
  }

  var obj = {
    "bar": "#x"
  }

  test(t => {
    createURLTest('TestPolicyURL6', { createURL: getURL.bind(obj) }, INPUTS.URL + "#x", t);
  }, "url = this bound to an object");

  var bar = "#x";
  test(t => {
    createURLTest('TestPolicyURL7', { createURL: s => getURL(s) }, INPUTS.URL + bar, t);
  }, "url = this without bind");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyURL8', null);
    assert_throws(new TypeError(), _ => {
      p.createURL(INPUTS.URL);
    });
  }, "url - calling undefined callback throws");

  test(t => {
    let p = window.TrustedTypes.createPolicy('TestPolicyURL9', { createURL: createURLJS });
    assert_throws(new TypeError(), _ => {
      p.createHTML(INPUTS.HTML);
    });
    assert_throws(new TypeError(), _ => {
      p.createScript(INPUTS.SCRIPT);
    });
    assert_throws(new TypeError(), _ => {
      p.createScriptURL(INPUTS.SCRIPTURL);
    });
  }, "createURL defined - calling undefined callbacks throws");
</script>
